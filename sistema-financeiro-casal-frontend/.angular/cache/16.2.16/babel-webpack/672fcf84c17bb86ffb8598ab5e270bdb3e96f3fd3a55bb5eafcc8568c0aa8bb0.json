{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/Bomfim/Documents/GitHub/Controle-financeiro-casal/workspace/sistema-financeiro-casal-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport WebSocket from './WebSocket';\nimport { CHANNEL_EVENTS, CONNECTION_STATE, DEFAULT_HEADERS, DEFAULT_TIMEOUT, SOCKET_STATES, TRANSPORTS, VSN, WS_CLOSE_NORMAL } from './lib/constants';\nimport Serializer from './lib/serializer';\nimport Timer from './lib/timer';\nimport { httpEndpointURL } from './lib/transformers';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => {};\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nexport default class RealtimeClient {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.logLevel Sets the log level for Realtime\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n   */\n  constructor(endPoint, options) {\n    var _this = this;\n    var _a;\n    this.accessTokenValue = null;\n    this.apiKey = null;\n    this.channels = new Array();\n    this.endPoint = '';\n    this.httpEndpoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.heartbeatIntervalMs = 25000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.heartbeatCallback = noop;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.accessToken = null;\n    /**\n     * Use either custom fetch, if provided, or default fetch to make HTTP requests\n     *\n     * @internal\n     */\n    this._resolveFetch = customFetch => {\n      let _fetch;\n      if (customFetch) {\n        _fetch = customFetch;\n      } else if (typeof fetch === 'undefined') {\n        _fetch = (...args) => import('@supabase/node-fetch').then(({\n          default: fetch\n        }) => fetch(...args));\n      } else {\n        _fetch = fetch;\n      }\n      return (...args) => _fetch(...args);\n    };\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n    this.httpEndpoint = httpEndpointURL(endPoint);\n    if (options === null || options === void 0 ? void 0 : options.transport) {\n      this.transport = options.transport;\n    } else {\n      this.transport = null;\n    }\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n      this.logLevel = options.logLevel || options.log_level;\n      this.params = Object.assign(Object.assign({}, this.params), {\n        log_level: this.logLevel\n      });\n    }\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    const accessTokenValue = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;\n    if (accessTokenValue) {\n      this.accessTokenValue = accessTokenValue;\n      this.apiKey = accessTokenValue;\n    }\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer( /*#__PURE__*/_asyncToGenerator(function* () {\n      _this.disconnect();\n      _this.connect();\n    }), this.reconnectAfterMs);\n    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    if (options === null || options === void 0 ? void 0 : options.worker) {\n      if (typeof window !== 'undefined' && !window.Worker) {\n        throw new Error('Web Worker is not supported');\n      }\n      this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;\n      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n    }\n    this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect() {\n    if (this.conn) {\n      return;\n    }\n    if (!this.transport) {\n      this.transport = WebSocket;\n    }\n    if (this.transport) {\n      // Detect if using the native browser WebSocket\n      const isBrowser = typeof window !== 'undefined' && this.transport === window.WebSocket;\n      if (isBrowser) {\n        this.conn = new this.transport(this.endpointURL());\n      } else {\n        this.conn = new this.transport(this.endpointURL(), undefined, {\n          headers: this.headers\n        });\n      }\n      this.setupConnection();\n      return;\n    }\n    this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {\n      close: () => {\n        this.conn = null;\n      }\n    });\n  }\n  /**\n   * Returns the URL of the websocket.\n   * @returns string The URL of the websocket.\n   */\n  endpointURL() {\n    return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n      vsn: VSN\n    }));\n  }\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code, reason) {\n    if (this.conn) {\n      this.conn.onclose = function () {}; // noop\n      if (code) {\n        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n      } else {\n        this.conn.close();\n      }\n      this.conn = null;\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.reset();\n      this.channels.forEach(channel => channel.teardown());\n    }\n  }\n  /**\n   * Returns all created channels\n   */\n  getChannels() {\n    return this.channels;\n  }\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  removeChannel(channel) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const status = yield channel.unsubscribe();\n      _this2.channels = _this2.channels.filter(c => c._joinRef !== channel._joinRef);\n      if (_this2.channels.length === 0) {\n        _this2.disconnect();\n      }\n      return status;\n    })();\n  }\n  /**\n   * Unsubscribes and removes all channels\n   */\n  removeAllChannels() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const values_1 = yield Promise.all(_this3.channels.map(channel => channel.unsubscribe()));\n      _this3.channels = [];\n      _this3.disconnect();\n      return values_1;\n    })();\n  }\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind, msg, data) {\n    this.logger(kind, msg, data);\n  }\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting;\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open;\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing;\n      default:\n        return CONNECTION_STATE.Closed;\n    }\n  }\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected() {\n    return this.connectionState() === CONNECTION_STATE.Open;\n  }\n  channel(topic, params = {\n    config: {}\n  }) {\n    const realtimeTopic = `realtime:${topic}`;\n    const exists = this.getChannels().find(c => c.topic === realtimeTopic);\n    if (!exists) {\n      const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n      this.channels.push(chan);\n      return chan;\n    } else {\n      return exists;\n    }\n  }\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data) {\n    const {\n      topic,\n      event,\n      payload,\n      ref\n    } = data;\n    const callback = () => {\n      this.encode(data, result => {\n        var _a;\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n      });\n    };\n    this.log('push', `${topic} ${event} (${ref})`, payload);\n    if (this.isConnected()) {\n      callback();\n    } else {\n      this.sendBuffer.push(callback);\n    }\n  }\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\n   *\n   * On callback used, it will set the value of the token internal to the client.\n   *\n   * @param token A JWT string to override the token set on the client.\n   */\n  setAuth() {\n    var _this4 = this;\n    return _asyncToGenerator(function* (token = null) {\n      let tokenToSend = token || _this4.accessToken && (yield _this4.accessToken()) || _this4.accessTokenValue;\n      if (_this4.accessTokenValue != tokenToSend) {\n        _this4.accessTokenValue = tokenToSend;\n        _this4.channels.forEach(channel => {\n          tokenToSend && channel.updateJoinPayload({\n            access_token: tokenToSend,\n            version: _this4.headers && _this4.headers['X-Client-Info']\n          });\n          if (channel.joinedOnce && channel._isJoined()) {\n            channel._push(CHANNEL_EVENTS.access_token, {\n              access_token: tokenToSend\n            });\n          }\n        });\n      }\n    }).apply(this, arguments);\n  }\n  /**\n   * Sends a heartbeat message if the socket is connected.\n   */\n  sendHeartbeat() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      if (!_this5.isConnected()) {\n        _this5.heartbeatCallback('disconnected');\n        return;\n      }\n      if (_this5.pendingHeartbeatRef) {\n        _this5.pendingHeartbeatRef = null;\n        _this5.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n        _this5.heartbeatCallback('timeout');\n        (_a = _this5.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n        return;\n      }\n      _this5.pendingHeartbeatRef = _this5._makeRef();\n      _this5.push({\n        topic: 'phoenix',\n        event: 'heartbeat',\n        payload: {},\n        ref: _this5.pendingHeartbeatRef\n      });\n      _this5.heartbeatCallback('sent');\n      yield _this5.setAuth();\n    })();\n  }\n  onHeartbeat(callback) {\n    this.heartbeatCallback = callback;\n  }\n  /**\n   * Flushes send buffer\n   */\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach(callback => callback());\n      this.sendBuffer = [];\n    }\n  }\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef() {\n    let newRef = this.ref + 1;\n    if (newRef === this.ref) {\n      this.ref = 0;\n    } else {\n      this.ref = newRef;\n    }\n    return this.ref.toString();\n  }\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic) {\n    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`);\n      dupChannel.unsubscribe();\n    }\n  }\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel) {\n    this.channels = this.channels.filter(c => c.topic !== channel.topic);\n  }\n  /**\n   * Sets up connection handlers.\n   *\n   * @internal\n   */\n  setupConnection() {\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer';\n      this.conn.onopen = () => this._onConnOpen();\n      this.conn.onerror = error => this._onConnError(error);\n      this.conn.onmessage = event => this._onConnMessage(event);\n      this.conn.onclose = event => this._onConnClose(event);\n    }\n  }\n  /** @internal */\n  _onConnMessage(rawMessage) {\n    this.decode(rawMessage.data, msg => {\n      let {\n        topic,\n        event,\n        payload,\n        ref\n      } = msg;\n      if (topic === 'phoenix' && event === 'phx_reply') {\n        this.heartbeatCallback(msg.payload.status == 'ok' ? 'ok' : 'error');\n      }\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n      }\n      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);\n      Array.from(this.channels).filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));\n      this.stateChangeCallbacks.message.forEach(callback => callback(msg));\n    });\n  }\n  /** @internal */\n  _onConnOpen() {\n    this.log('transport', `connected to ${this.endpointURL()}`);\n    this.flushSendBuffer();\n    this.reconnectTimer.reset();\n    if (!this.worker) {\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n    } else {\n      if (this.workerUrl) {\n        this.log('worker', `starting worker for from ${this.workerUrl}`);\n      } else {\n        this.log('worker', `starting default worker`);\n      }\n      const objectUrl = this._workerObjectUrl(this.workerUrl);\n      this.workerRef = new Worker(objectUrl);\n      this.workerRef.onerror = error => {\n        this.log('worker', 'worker error', error.message);\n        this.workerRef.terminate();\n      };\n      this.workerRef.onmessage = event => {\n        if (event.data.event === 'keepAlive') {\n          this.sendHeartbeat();\n        }\n      };\n      this.workerRef.postMessage({\n        event: 'start',\n        interval: this.heartbeatIntervalMs\n      });\n    }\n    this.stateChangeCallbacks.open.forEach(callback => callback());\n  }\n  /** @internal */\n  _onConnClose(event) {\n    this.log('transport', 'close', event);\n    this._triggerChanError();\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n    this.reconnectTimer.scheduleTimeout();\n    this.stateChangeCallbacks.close.forEach(callback => callback(event));\n  }\n  /** @internal */\n  _onConnError(error) {\n    this.log('transport', error.message);\n    this._triggerChanError();\n    this.stateChangeCallbacks.error.forEach(callback => callback(error));\n  }\n  /** @internal */\n  _triggerChanError() {\n    this.channels.forEach(channel => channel._trigger(CHANNEL_EVENTS.error));\n  }\n  /** @internal */\n  _appendParams(url, params) {\n    if (Object.keys(params).length === 0) {\n      return url;\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?';\n    const query = new URLSearchParams(params);\n    return `${url}${prefix}${query}`;\n  }\n  _workerObjectUrl(url) {\n    let result_url;\n    if (url) {\n      result_url = url;\n    } else {\n      const blob = new Blob([WORKER_SCRIPT], {\n        type: 'application/javascript'\n      });\n      result_url = URL.createObjectURL(blob);\n    }\n    return result_url;\n  }\n}\nclass WSWebSocketDummy {\n  constructor(address, _protocols, options) {\n    this.binaryType = 'arraybuffer';\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n    this.onopen = () => {};\n    this.readyState = SOCKET_STATES.connecting;\n    this.send = () => {};\n    this.url = null;\n    this.url = address;\n    this.close = options.close;\n  }\n}","map":{"version":3,"names":["WebSocket","CHANNEL_EVENTS","CONNECTION_STATE","DEFAULT_HEADERS","DEFAULT_TIMEOUT","SOCKET_STATES","TRANSPORTS","VSN","WS_CLOSE_NORMAL","Serializer","Timer","httpEndpointURL","RealtimeChannel","noop","WORKER_SCRIPT","RealtimeClient","constructor","endPoint","options","_this","_a","accessTokenValue","apiKey","channels","Array","httpEndpoint","headers","params","timeout","heartbeatIntervalMs","heartbeatTimer","undefined","pendingHeartbeatRef","heartbeatCallback","ref","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","accessToken","_resolveFetch","customFetch","_fetch","fetch","args","then","default","websocket","transport","Object","assign","logLevel","log_level","apikey","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","bind","reconnectTimer","_asyncToGenerator","disconnect","connect","worker","window","Worker","Error","workerUrl","isBrowser","endpointURL","setupConnection","WSWebSocketDummy","_appendParams","vsn","code","reason","onclose","clearInterval","reset","forEach","channel","teardown","getChannels","removeChannel","_this2","status","unsubscribe","filter","c","_joinRef","length","removeAllChannels","_this3","values_1","Promise","all","map","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","topic","config","realtimeTopic","exists","find","chan","push","event","result","send","setAuth","_this4","token","tokenToSend","updateJoinPayload","access_token","version","joinedOnce","_isJoined","_push","apply","arguments","sendHeartbeat","_this5","_makeRef","onHeartbeat","flushSendBuffer","newRef","toString","_leaveOpenTopic","dupChannel","_isJoining","_remove","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnMessage","_onConnClose","rawMessage","from","_isMember","_trigger","setInterval","objectUrl","_workerObjectUrl","workerRef","terminate","postMessage","interval","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","result_url","blob","Blob","type","URL","createObjectURL","address","_protocols"],"sources":["C:/Users/Bomfim/Documents/GitHub/Controle-financeiro-casal/workspace/sistema-financeiro-casal-frontend/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js"],"sourcesContent":["import WebSocket from './WebSocket';\nimport { CHANNEL_EVENTS, CONNECTION_STATE, DEFAULT_HEADERS, DEFAULT_TIMEOUT, SOCKET_STATES, TRANSPORTS, VSN, WS_CLOSE_NORMAL, } from './lib/constants';\nimport Serializer from './lib/serializer';\nimport Timer from './lib/timer';\nimport { httpEndpointURL } from './lib/transformers';\nimport RealtimeChannel from './RealtimeChannel';\nconst noop = () => { };\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nexport default class RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers The optional headers to pass when connecting.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.logLevel Sets the log level for Realtime\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     */\n    constructor(endPoint, options) {\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this.channels = new Array();\n        this.endPoint = '';\n        this.httpEndpoint = '';\n        this.headers = DEFAULT_HEADERS;\n        this.params = {};\n        this.timeout = DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs = 25000;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.heartbeatCallback = noop;\n        this.ref = 0;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new Serializer();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: [],\n        };\n        this.accessToken = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */\n        this._resolveFetch = (customFetch) => {\n            let _fetch;\n            if (customFetch) {\n                _fetch = customFetch;\n            }\n            else if (typeof fetch === 'undefined') {\n                _fetch = (...args) => import('@supabase/node-fetch').then(({ default: fetch }) => fetch(...args));\n            }\n            else {\n                _fetch = fetch;\n            }\n            return (...args) => _fetch(...args);\n        };\n        this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n        this.httpEndpoint = httpEndpointURL(endPoint);\n        if (options === null || options === void 0 ? void 0 : options.transport) {\n            this.transport = options.transport;\n        }\n        else {\n            this.transport = null;\n        }\n        if (options === null || options === void 0 ? void 0 : options.params)\n            this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.headers)\n            this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n        if (options === null || options === void 0 ? void 0 : options.timeout)\n            this.timeout = options.timeout;\n        if (options === null || options === void 0 ? void 0 : options.logger)\n            this.logger = options.logger;\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n            this.logLevel = options.logLevel || options.log_level;\n            this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel });\n        }\n        if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs)\n            this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n        const accessTokenValue = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;\n        if (accessTokenValue) {\n            this.accessTokenValue = accessTokenValue;\n            this.apiKey = accessTokenValue;\n        }\n        this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs)\n            ? options.reconnectAfterMs\n            : (tries) => {\n                return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n            };\n        this.encode = (options === null || options === void 0 ? void 0 : options.encode)\n            ? options.encode\n            : (payload, callback) => {\n                return callback(JSON.stringify(payload));\n            };\n        this.decode = (options === null || options === void 0 ? void 0 : options.decode)\n            ? options.decode\n            : this.serializer.decode.bind(this.serializer);\n        this.reconnectTimer = new Timer(async () => {\n            this.disconnect();\n            this.connect();\n        }, this.reconnectAfterMs);\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n        if (options === null || options === void 0 ? void 0 : options.worker) {\n            if (typeof window !== 'undefined' && !window.Worker) {\n                throw new Error('Web Worker is not supported');\n            }\n            this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n        this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */\n    connect() {\n        if (this.conn) {\n            return;\n        }\n        if (!this.transport) {\n            this.transport = WebSocket;\n        }\n        if (this.transport) {\n            // Detect if using the native browser WebSocket\n            const isBrowser = typeof window !== 'undefined' && this.transport === window.WebSocket;\n            if (isBrowser) {\n                this.conn = new this.transport(this.endpointURL());\n            }\n            else {\n                this.conn = new this.transport(this.endpointURL(), undefined, {\n                    headers: this.headers,\n                });\n            }\n            this.setupConnection();\n            return;\n        }\n        this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {\n            close: () => {\n                this.conn = null;\n            },\n        });\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */\n    endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: VSN }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n    disconnect(code, reason) {\n        if (this.conn) {\n            this.conn.onclose = function () { }; // noop\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n            }\n            else {\n                this.conn.close();\n            }\n            this.conn = null;\n            // remove open handles\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.reconnectTimer.reset();\n            this.channels.forEach((channel) => channel.teardown());\n        }\n    }\n    /**\n     * Returns all created channels\n     */\n    getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n    async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        this.channels = this.channels.filter((c) => c._joinRef !== channel._joinRef);\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n    async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel) => channel.unsubscribe()));\n        this.channels = [];\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n    log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n    connectionState() {\n        switch (this.conn && this.conn.readyState) {\n            case SOCKET_STATES.connecting:\n                return CONNECTION_STATE.Connecting;\n            case SOCKET_STATES.open:\n                return CONNECTION_STATE.Open;\n            case SOCKET_STATES.closing:\n                return CONNECTION_STATE.Closing;\n            default:\n                return CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n    isConnected() {\n        return this.connectionState() === CONNECTION_STATE.Open;\n    }\n    channel(topic, params = { config: {} }) {\n        const realtimeTopic = `realtime:${topic}`;\n        const exists = this.getChannels().find((c) => c.topic === realtimeTopic);\n        if (!exists) {\n            const chan = new RealtimeChannel(`realtime:${topic}`, params, this);\n            this.channels.push(chan);\n            return chan;\n        }\n        else {\n            return exists;\n        }\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n    push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = () => {\n            this.encode(data, (result) => {\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log('push', `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        }\n        else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * @param token A JWT string to override the token set on the client.\n     */\n    async setAuth(token = null) {\n        let tokenToSend = token ||\n            (this.accessToken && (await this.accessToken())) ||\n            this.accessTokenValue;\n        if (this.accessTokenValue != tokenToSend) {\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel) => {\n                tokenToSend &&\n                    channel.updateJoinPayload({\n                        access_token: tokenToSend,\n                        version: this.headers && this.headers['X-Client-Info'],\n                    });\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend,\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */\n    async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            this.heartbeatCallback('disconnected');\n            return;\n        }\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n            this.heartbeatCallback('timeout');\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n            return;\n        }\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: 'phoenix',\n            event: 'heartbeat',\n            payload: {},\n            ref: this.pendingHeartbeatRef,\n        });\n        this.heartbeatCallback('sent');\n        await this.setAuth();\n    }\n    onHeartbeat(callback) {\n        this.heartbeatCallback = callback;\n    }\n    /**\n     * Flushes send buffer\n     */\n    flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback) => callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n    _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        }\n        else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n    _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c) => c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log('transport', `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n    _remove(channel) {\n        this.channels = this.channels.filter((c) => c.topic !== channel.topic);\n    }\n    /**\n     * Sets up connection handlers.\n     *\n     * @internal\n     */\n    setupConnection() {\n        if (this.conn) {\n            this.conn.binaryType = 'arraybuffer';\n            this.conn.onopen = () => this._onConnOpen();\n            this.conn.onerror = (error) => this._onConnError(error);\n            this.conn.onmessage = (event) => this._onConnMessage(event);\n            this.conn.onclose = (event) => this._onConnClose(event);\n        }\n    }\n    /** @internal */\n    _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg) => {\n            let { topic, event, payload, ref } = msg;\n            if (topic === 'phoenix' && event === 'phx_reply') {\n                this.heartbeatCallback(msg.payload.status == 'ok' ? 'ok' : 'error');\n            }\n            if (ref && ref === this.pendingHeartbeatRef) {\n                this.pendingHeartbeatRef = null;\n            }\n            this.log('receive', `${payload.status || ''} ${topic} ${event} ${(ref && '(' + ref + ')') || ''}`, payload);\n            Array.from(this.channels)\n                .filter((channel) => channel._isMember(topic))\n                .forEach((channel) => channel._trigger(event, payload, ref));\n            this.stateChangeCallbacks.message.forEach((callback) => callback(msg));\n        });\n    }\n    /** @internal */\n    _onConnOpen() {\n        this.log('transport', `connected to ${this.endpointURL()}`);\n        this.flushSendBuffer();\n        this.reconnectTimer.reset();\n        if (!this.worker) {\n            this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n        }\n        else {\n            if (this.workerUrl) {\n                this.log('worker', `starting worker for from ${this.workerUrl}`);\n            }\n            else {\n                this.log('worker', `starting default worker`);\n            }\n            const objectUrl = this._workerObjectUrl(this.workerUrl);\n            this.workerRef = new Worker(objectUrl);\n            this.workerRef.onerror = (error) => {\n                this.log('worker', 'worker error', error.message);\n                this.workerRef.terminate();\n            };\n            this.workerRef.onmessage = (event) => {\n                if (event.data.event === 'keepAlive') {\n                    this.sendHeartbeat();\n                }\n            };\n            this.workerRef.postMessage({\n                event: 'start',\n                interval: this.heartbeatIntervalMs,\n            });\n        }\n        this.stateChangeCallbacks.open.forEach((callback) => callback());\n    }\n    /** @internal */\n    _onConnClose(event) {\n        this.log('transport', 'close', event);\n        this._triggerChanError();\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.scheduleTimeout();\n        this.stateChangeCallbacks.close.forEach((callback) => callback(event));\n    }\n    /** @internal */\n    _onConnError(error) {\n        this.log('transport', error.message);\n        this._triggerChanError();\n        this.stateChangeCallbacks.error.forEach((callback) => callback(error));\n    }\n    /** @internal */\n    _triggerChanError() {\n        this.channels.forEach((channel) => channel._trigger(CHANNEL_EVENTS.error));\n    }\n    /** @internal */\n    _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? '&' : '?';\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        }\n        else {\n            const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n}\nclass WSWebSocketDummy {\n    constructor(address, _protocols, options) {\n        this.binaryType = 'arraybuffer';\n        this.onclose = () => { };\n        this.onerror = () => { };\n        this.onmessage = () => { };\n        this.onopen = () => { };\n        this.readyState = SOCKET_STATES.connecting;\n        this.send = () => { };\n        this.url = null;\n        this.url = address;\n        this.close = options.close;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}